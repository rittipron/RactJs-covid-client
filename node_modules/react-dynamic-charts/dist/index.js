'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var React__default = _interopDefault(React);
var PropTypes = _interopDefault(require('prop-types'));

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();

function getRandomColor() {
  var letters = '0123456789ABCDEF';
  var color = '#';
  for (var i = 0; i < 6; i++) {
    color += letters[Math.floor(Math.random() * 16)];
  }
  return color;
}
function DynamicBarChart(props) {
  var _useState = React.useState([]),
      _useState2 = slicedToArray(_useState, 2),
      dataQueue = _useState2[0],
      setDataQueue = _useState2[1];

  var _useState3 = React.useState(0),
      _useState4 = slicedToArray(_useState3, 2),
      activeItemIdx = _useState4[0],
      setActiveItemIdx = _useState4[1];

  var _useState5 = React.useState(0),
      _useState6 = slicedToArray(_useState5, 2),
      highestValue = _useState6[0],
      setHighestValue = _useState6[1];

  var _useState7 = React.useState({}),
      _useState8 = slicedToArray(_useState7, 2),
      currentValues = _useState8[0],
      setCurrentValues = _useState8[1];

  var _useState9 = React.useState(false),
      _useState10 = slicedToArray(_useState9, 2),
      firstRun = _useState10[0],
      setFirstRun = _useState10[1];

  var _useState11 = React.useState(false),
      _useState12 = slicedToArray(_useState11, 2),
      afterClick = _useState12[0],
      setAfterClick = _useState12[1];

  var iterationTimeoutHolder = null;

  function start() {
    if (activeItemIdx > 1) {
      return;
    }
    if (props.onRunStart) {
      props.onRunStart();
    }
    nextStep(true);
  }

  function setNextValues() {
    if (!dataQueue[activeItemIdx]) {
      iterationTimeoutHolder = null;
      if (props.onRunEnd) {
        props.onRunEnd();
      }
      return;
    }

    var roundData = dataQueue[activeItemIdx].values;
    var nextValues = {};
    var highestValue = 0;
    roundData.map(function (c) {
      nextValues[c.id] = _extends({}, c, {
        color: c.color || (currentValues[c.id] || {}).color || getRandomColor()
      });

      if (Math.abs(c.value) > highestValue) {
        highestValue = Math.abs(c.value);
      }

      return c;
    });

    setCurrentValues(nextValues);
    setHighestValue(highestValue);
    setActiveItemIdx(activeItemIdx + 1);
  }

  function nextStep() {
    var firstRun = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    setFirstRun(firstRun);
    setNextValues();
  }

  React.useEffect(function () {
    setDataQueue(props.data);
  }, []);

  React.useEffect(function () {
    if (props.startAutomatically) {
      start();
    } else {
      setNextValues();
    }
  }, [dataQueue]);

  React.useEffect(function () {
    if (props.startAutomatically || afterClick) {
      iterationTimeoutHolder = window.setTimeout(nextStep, firstRun ? props.startRunningTimeout : props.iterationTimeout);
    }

    return function () {
      if (iterationTimeoutHolder) {
        window.clearTimeout(iterationTimeoutHolder);
      }
    };
  }, [activeItemIdx, afterClick]);

  var barHeight = props.barHeight,
      baseline = props.baseline,
      iterationTimeout = props.iterationTimeout,
      chartWrapperStyles = props.chartWrapperStyles,
      mainWrapperStyles = props.mainWrapperStyles,
      iterationTitleStyles = props.iterationTitleStyles,
      labelStyles = props.labelStyles,
      baselineStyles = props.baselineStyles,
      showTitle = props.showTitle;

  var maxValue = highestValue / 0.85;
  var sortedCurrentValues = Object.keys(currentValues).sort(function (a, b) {
    return currentValues[b].value - currentValues[a].value;
  });
  var hasBaseline = baseline !== null && !isNaN(baseline);
  var currentItem = dataQueue[activeItemIdx - 1] || {};

  return React__default.createElement(
    'div',
    { className: 'live-chart', style: mainWrapperStyles },
    React__default.createElement(
      React__default.Fragment,
      null,
      showTitle && React__default.createElement(
        'h1',
        { style: iterationTitleStyles },
        currentItem.name
      ),
      React__default.createElement(
        'section',
        { className: 'chart', style: chartWrapperStyles },
        hasBaseline && React__default.createElement(
          'div',
          { className: 'baseline', style: baselineStyles },
          React__default.createElement(
            'span',
            null,
            baseline
          )
        ),
        React__default.createElement(
          'div',
          { className: 'chart-bars ' + (hasBaseline ? 'with-baseline' : ''), style: { height: (barHeight + 20) * Object.keys(currentValues).length } },
          sortedCurrentValues.map(function (key, idx) {
            var currentValueData = currentValues[key];
            var value = hasBaseline ? (currentValueData.value || baseline) - baseline : currentValueData.value;
            var width = Math.abs(value / maxValue * 100);
            var behindbaseline = false;
            if (hasBaseline && currentValueData.value < baseline) {
              behindbaseline = true;
            }

            if (hasBaseline) {
              width = width / 2;
            }

            var widthStr = void 0;
            if (isNaN(width) || !width) {
              widthStr = '1px';
            } else {
              widthStr = width + '%';
            }

            return React__default.createElement(
              'div',
              { className: 'bar-wrapper ' + (behindbaseline ? 'behind-baseline' : ''), style: { top: (barHeight + 20) * idx, transitionDuration: iterationTimeout / 1000 }, key: 'bar_' + key },
              React__default.createElement(
                'label',
                { style: labelStyles },
                !currentValueData.label ? key : currentValueData.label
              ),
              React__default.createElement('div', { className: 'bar', style: { height: barHeight, width: widthStr, background: typeof currentValueData.color === 'string' ? currentValueData.color : 'linear-gradient(to right, ' + currentValueData.color.join(',') + ')' } }),
              React__default.createElement(
                'span',
                { className: 'value', style: { color: typeof currentValueData.color === 'string' ? currentValueData.color : currentValueData.color[0] } },
                currentValueData.value
              )
            );
          })
        )
      )
    ),
    props.showStartButton && React__default.createElement(
      'button',
      { className: 'start-button', onClick: function onClick() {
          return setAfterClick(true);
        }, style: props.startButtonStyles },
      props.startButtonText
    )
  );
}
DynamicBarChart.propTypes = {
  startAutomatically: PropTypes.bool,
  showTitle: PropTypes.bool,
  iterationTimeout: PropTypes.number,
  data: PropTypes.array,
  startRunningTimeout: PropTypes.number,
  barHeight: PropTypes.number,
  baseline: PropTypes.number,
  showStartButton: PropTypes.bool,
  startButtonText: PropTypes.string,
  mainWrapperStyles: PropTypes.object,
  chartWrapperStyles: PropTypes.object,
  baselineStyles: PropTypes.object,
  iterationTitleStyles: PropTypes.object,
  labelStyles: PropTypes.object,
  startButtonStyles: PropTypes.object,
  onRunStart: PropTypes.func,
  onRunEnd: PropTypes.func
};

DynamicBarChart.defaultProps = {
  startAutomatically: true,
  showTitle: true,
  iterationTimeout: 200,
  data: [],
  startRunningTimeout: 0,
  barHeight: 50,
  baseline: null,
  showStartButton: false,
  startButtonText: 'Start',
  mainWrapperStyles: {},
  chartWrapperStyles: {},
  baselineStyles: {},
  iterationTitleStyles: {},
  labelStyles: {},
  startButtonStyles: {},
  onRunStart: null,
  onRunEnd: null
};

exports.DynamicBarChart = DynamicBarChart;
//# sourceMappingURL=index.js.map
